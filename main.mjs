import http from 'http';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
// Ð’ Ð½Ð°Ñ‡Ð°Ð»Ðµ Ñ„Ð°Ð¹Ð»Ð° Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ
import os from 'os';

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ yt-dlp Ð¿Ñ€Ð¸ ÑÑ‚Ð°Ñ€Ñ‚Ðµ
async function initialize() {
    const hasYtDlp = await checkYtDlp();
    if (!hasYtDlp) {
        console.log('ðŸ’¡ Ð”Ð»Ñ ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ¾Ð² Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ:');
        console.log('wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -O ~/yt-dlp');
        console.log('chmod +x ~/yt-dlp');
    }
    
    // ... Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ð°Ñ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ
}
import { parseFile } from 'music-metadata';
import { exec } from 'child_process';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const AUDIO_DIR = path.join(__dirname, 'audio');
const PORT = 8000;

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ IP-Ð°Ð´Ñ€ÐµÑÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°
function getServerIP() {
    const interfaces = os.networkInterfaces();
    for (const interfaceName of Object.keys(interfaces)) {
        for (const iface of interfaces[interfaceName]) {
            if (iface.family === 'IPv4' && !iface.internal) {
                return iface.address;
            }
        }
    }
    return 'localhost';
}

const SERVER_IP = getServerIP();

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð»Ð¸ yt-dlp
// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð»Ð¸ yt-dlp
async function checkYtDlp() {
    return new Promise((resolve) => {
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ñ… Ð¼ÐµÑÑ‚
        const checkCommands = [
            'test -f ~/yt-dlp && echo "home"',
            'which yt-dlp 2>/dev/null && echo "system"',
            'test -f /usr/local/bin/yt-dlp && echo "local"'
        ];
        
        exec(checkCommands.join(' || '), (error, stdout) => {
            if (stdout && stdout.trim()) {
                const location = stdout.trim();
                console.log(`âœ… yt-dlp Ð½Ð°Ð¹Ð´ÐµÐ½ (${location})`);
                resolve(true);
            } else {
                console.log('âŒ yt-dlp Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½. Ð¡ÐºÐ°Ñ‡Ð°Ð¹Ñ‚Ðµ:');
                console.log('wget https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -O ~/yt-dlp');
                console.log('chmod +x ~/yt-dlp');
                resolve(false);
            }
        });
    });
}

async function safeDeleteFile(filePath) {
    try {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            console.log(`ðŸ—‘ï¸  Ð£Ð´Ð°Ð»ÐµÐ½ Ñ„Ð°Ð¹Ð»: ${filePath}`);
        }
    } catch (error) {
        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ñ„Ð°Ð¹Ð»Ð°:', error);
    }
}

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð»Ð¸ ffmpeg
async function checkFfmpeg() {
    return new Promise((resolve) => {
        exec('which ffmpeg', (error) => {
            if (error) {
                console.log('âŒ ffmpeg Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½. Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ: sudo apt install ffmpeg');
                resolve(false);
            } else {
                console.log('âœ… ffmpeg ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½');
                resolve(true);
            }
        });
    });
}

// ÐŸÐ¾Ð¸ÑÐº Ñ‚Ñ€ÐµÐºÐ° Ð½Ð° YouTube
async function searchYouTube(trackName) {
    try {
        console.log(`ðŸ” Ð˜Ñ‰ÐµÐ¼ Ñ‚Ñ€ÐµÐº: "${trackName}"`);
        
        const searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(trackName)}`;
        const response = await fetch(searchUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
        });
        
        const html = await response.text();
        
        // Ð˜Ñ‰ÐµÐ¼ videoId Ð² HTML
        const regex = /"videoId":"([^"]{11})"/;
        const match = html.match(regex);
        
        if (match && match[1]) {
            const videoId = match[1];
            const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
            console.log(`âœ… ÐÐ°Ð¹Ð´ÐµÐ½ Ð²Ð¸Ð´ÐµÐ¾: ${videoUrl}`);
            return videoUrl;
        }
        
        console.log('âŒ Ð¢Ñ€ÐµÐº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½');
        return null;
        
    } catch (error) {
        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð¸ÑÐºÐ°:', error);
        return null;
    }
}

// Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ðµ Ñ‡ÐµÑ€ÐµÐ· yt-dlp
async function downloadYouTubeTrack(videoUrl, trackName) {
    return new Promise((resolve, reject) => {
        console.log(`ðŸ“¥ Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°ÐµÐ¼: ${videoUrl}`);
        
        const safeName = trackName.replace(/[^a-zA-Z0-9]/g, '_').slice(0, 50);
        const outputTemplate = path.join(AUDIO_DIR, `${safeName}.%(ext)s`);
        
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð³Ð´Ðµ Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÑÑ yt-dlp
        const ytDlpCommand = fs.existsSync(path.join(os.homedir(), 'yt-dlp')) ? 
            path.join(os.homedir(), 'yt-dlp') : 'yt-dlp';
        
        // ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° Ð´Ð»Ñ yt-dlp
        const command = `${ytDlpCommand} -x --audio-format mp3 --audio-quality 0 -o "${outputTemplate}" "${videoUrl}"`;
        
        console.log(`â–¶ï¸  Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼: ${command}`);
        
        exec(command, { timeout: 120000 }, (error, stdout, stderr) => {
            // ... Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ ÐºÐ¾Ð´ Ð±ÐµÐ· Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹
        });
    });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ð¾Ð² Ñ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¼Ð¸ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑÐ¼Ð¸
async function getAudioFilesWithDurations() {
    try {
        const files = fs.readdirSync(AUDIO_DIR)
            .filter(file => {
                const ext = path.extname(file).toLowerCase();
                return ['.mp3', '.wav', '.ogg', '.m4a', '.flac'].includes(ext);
            })
            .map(file => path.join(AUDIO_DIR, file));

        const filesWithDurations = [];
        
        for (const filePath of files) {
            try {
                const metadata = await parseFile(filePath);
                const durationMs = metadata.format.duration ? Math.round(metadata.format.duration * 1000) : 180000;
                
                filesWithDurations.push({
                    path: filePath,
                    duration: durationMs,
                    name: path.basename(filePath, path.extname(filePath))
                });
                
            } catch (error) {
                console.error(`âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ñ… ${filePath}:`, error);
                filesWithDurations.push({
                    path: filePath,
                    duration: 180000,
                    name: path.basename(filePath, path.extname(filePath))
                });
            }
        }
        
        return filesWithDurations;
    } catch (err) {
        console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð¿Ð°Ð¿ÐºÐ¸ audio:', err);
        return [];
    }
}

// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð´Ð»Ñ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸
let audioFilesCache = [];
let currentTrackIndex = 0;
let trackStartTime = Date.now();
let activeConnections = new Set();

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ° Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ (Ð¿Ð¾ÑÐ»Ðµ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾)
// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ° Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ (Ð¿Ð¾ÑÐ»Ðµ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾)
async function addTrackToQueue(trackName) {
    console.log(`ðŸŽµ Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ: "${trackName}"`);
    
    try {
        // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸
        const hasYtDlp = await checkYtDlp();
        if (!hasYtDlp) {
            throw new Error('yt-dlp Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½');
        }

        // Ð˜Ñ‰ÐµÐ¼ Ñ‚Ñ€ÐµÐº Ð½Ð° YouTube
        const videoUrl = await searchYouTube(trackName);
        if (!videoUrl) {
            console.log('âŒ Ð¢Ñ€ÐµÐº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½');
            return false;
        }
        
        // Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°ÐµÐ¼ Ñ‚Ñ€ÐµÐº
        const filePath = await downloadYouTubeTrack(videoUrl, trackName);
        if (!filePath) {
            console.log('âŒ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐºÐ°Ñ‡Ð°Ñ‚ÑŒ Ñ‚Ñ€ÐµÐº');
            return false;
        }
        
        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ
        let durationMs = 180000;
        try {
            const metadata = await parseFile(filePath);
            durationMs = metadata.format.duration ? Math.round(metadata.format.duration * 1000) : 180000;
        } catch (error) {
            console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸:', error);
        }
        
        const newTrack = {
            path: filePath,
            duration: durationMs,
            name: path.basename(filePath, path.extname(filePath)),
            isDownloaded: true // ÐŸÐ¾Ð¼ÐµÑ‡Ð°ÐµÐ¼ ÐºÐ°Ðº ÑÐºÐ°Ñ‡Ð°Ð½Ð½Ñ‹Ð¹ Ð´Ð»Ñ Ð¿Ð¾ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ³Ð¾ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ
        };
        
        // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ñ‚Ñ€ÐµÐº Ð¡Ð ÐÐ—Ð£ ÐŸÐžÐ¡Ð›Ð• Ð¢Ð•ÐšÐ£Ð©Ð•Ð“Ðž
        const insertIndex = currentTrackIndex + 1;
        audioFilesCache.splice(insertIndex, 0, newTrack);
        
        console.log(`âœ… Ð¢Ñ€ÐµÐº Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½ Ð² Ð¿Ð¾Ð·Ð¸Ñ†Ð¸ÑŽ ${insertIndex + 1}: ${newTrack.name}`);
        console.log(`â±ï¸  Ð‘ÑƒÐ´ÐµÑ‚ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½ Ð¿Ð¾ÑÐ»Ðµ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ñ‚Ñ€ÐµÐºÐ°`);
        
        return true;
        
    } catch (error) {
        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ°:', error);
        return false;
    }
}

// ÐŸÑ€ÐµÐ´Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ„Ð°Ð¹Ð»Ð°Ñ…
getAudioFilesWithDurations().then(files => {
    audioFilesCache = files;
    console.log(`âœ… Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ ${files.length} Ñ‚Ñ€ÐµÐºÐ¾Ð² Ñ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¼Ð¸ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑÐ¼Ð¸`);
    
    console.log('\nðŸŽµ ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ:');
    audioFilesCache.forEach((track, index) => {
        console.log(`${index + 1}. ${track.name} (${Math.round(track.duration / 1000)} ÑÐµÐº)`);
    });
    
    startGlobalTrackTimer();
}).catch(err => {
    console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ‚Ñ€ÐµÐºÐ¾Ð²:', err);
});

// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ‚Ð°Ð¹Ð¼ÐµÑ€ Ð´Ð»Ñ ÑÐ¼ÐµÐ½Ñ‹ Ñ‚Ñ€ÐµÐºÐ¾Ð²
function startGlobalTrackTimer() {
    if (audioFilesCache.length === 0) return;

    function playNextTrack() {
        const track = audioFilesCache[currentTrackIndex];
        trackStartTime = Date.now();
        
        console.log(`\nðŸŒ Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ð¸Ð³Ñ€Ð°ÐµÑ‚: ${track.name} (${Math.round(track.duration / 1000)} ÑÐµÐº)`);
        
        activeConnections.forEach(res => {
            if (!res.finished) {
                sendTrackFromPosition(res, track, 0);
            }
        });

        setTimeout(playNextTrack, track.duration);
        
        currentTrackIndex = (currentTrackIndex + 1) % audioFilesCache.length;
    }

    console.log(`\nðŸš€ ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ`);
    playNextTrack();
}

// ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ñ‚Ñ€ÐµÐºÐ° Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸
function sendTrackFromPosition(res, track, positionMs) {
    if (positionMs >= track.duration) {
        positionMs = 0;
    }

    if (!fs.existsSync(track.path)) {
        console.error(`âŒ Ð¤Ð°Ð¹Ð» Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚: ${track.path}`);
        if (!res.finished) {
            res.end();
        }
        return;
    }

    const readStream = fs.createReadStream(track.path);
    
    if (positionMs > 0) {
        const bytesToSkip = Math.floor((positionMs / 1000) * 16000);
        let bytesSkipped = 0;
        
        readStream.on('data', (chunk) => {
            if (bytesSkipped < bytesToSkip) {
                bytesSkipped += chunk.length;
                if (bytesSkipped >= bytesToSkip) {
                    const remainingChunk = chunk.slice(bytesToSkip - (bytesSkipped - chunk.length));
                    if (remainingChunk.length > 0 && !res.finished) {
                        res.write(remainingChunk);
                    }
                }
            } else {
                if (!res.finished) {
                    res.write(chunk);
                }
            }
        });
    } else {
        readStream.pipe(res, { end: false });
    }

    readStream.on('end', () => {
        // Ð£Ð´Ð°Ð»ÑÐµÐ¼ Ñ„Ð°Ð¹Ð» ÐŸÐžÐ¡Ð›Ð• Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸
        if (track.path.includes(AUDIO_DIR)) {
            setTimeout(() => safeDeleteFile(track.path), 1000);
        }
    });

    readStream.on('error', (err) => {
        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ Ñ‚Ñ€ÐµÐºÐ°:', err);
        if (!res.finished) {
            res.end();
        }
    });
}

// Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ ÑÐµÑ€Ð²ÐµÑ€
// Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ ÑÐµÑ€Ð²ÐµÑ€
const server = http.createServer(async (req, res) => {
    // POST Ñ€Ð¾ÑƒÑ‚ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ‚Ñ€ÐµÐºÐ°
    if (req.url === '/add' && req.method === 'POST') {
        let body = '';
        
        req.on('data', chunk => {
            body += chunk.toString();
        });
        
        req.on('end', async () => {
            try {
                const { track } = JSON.parse(body);
                
                if (!track) {
                    res.writeHead(400, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ success: false, message: 'ÐÐµ ÑƒÐºÐ°Ð·Ð°Ð½Ð¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ñ€ÐµÐºÐ°' }));
                    return;
                }
                
                console.log(`ðŸ“¨ POST Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ: "${track}"`);
                
                // ÐÐ•ÐœÐ•Ð”Ð›Ð•ÐÐÐž Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÐµÐ¼ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñƒ
                res.writeHead(200, { 
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'POST, OPTIONS',
                    'Access-Control-Allow-Headers': 'Content-Type'
                });
                
                res.end(JSON.stringify({ 
                    success: true, 
                    message: 'Ð¢Ñ€ÐµÐº Ð¿Ñ€Ð¸Ð½ÑÑ‚ Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ' 
                }));
                
                // ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ðµ (Ð¿Ð¾ÑÐ»Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð° ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñƒ)
                setTimeout(async () => {
                    try {
                        const success = await addTrackToQueue(track);
                        console.log(success ? 'âœ… Ð¢Ñ€ÐµÐº Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½' : 'âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ');
                    } catch (error) {
                        console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ñ‚Ñ€ÐµÐºÐ°:', error);
                    }
                }, 100);
                
            } catch (error) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ success: false, message: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' }));
            }
        });
        
        return;
    }

    // ... Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ ÐºÐ¾Ð´ Ð±ÐµÐ· Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹
});

// Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ ÑÐµÑ€Ð²ÐµÑ€
server.listen(PORT, '0.0.0.0', () => {
    console.log(`
ðŸš€ Ð¡ÐµÑ€Ð²ÐµÑ€ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½: http://localhost:${PORT}
ðŸŽ§ ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸ Ð² Highrise: http://${SERVER_IP}:${PORT}/stream.mp3
âž• Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚Ñ€ÐµÐº: POST http://${SERVER_IP}:${PORT}/add

ðŸ“ ÐÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ñ‹ Ð¸Ð· Ð¿Ð°Ð¿ÐºÐ¸: ${AUDIO_DIR}
ðŸŒ Ð¡ÐµÑ€Ð²ÐµÑ€ Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð¿Ð¾ IP: ${SERVER_IP}

ðŸ’¡ Ð”Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ñ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð¸:
sudo apt update && sudo apt install yt-dlp ffmpeg
`);
});

process.on('SIGINT', () => {
    console.log('\nðŸ›‘ Ð’Ñ‹ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ ÑÐµÑ€Ð²ÐµÑ€...');
    activeConnections.forEach(res => {
        if (!res.finished) res.end();
    });
    process.exit(0);
});